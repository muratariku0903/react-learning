# 言語化演習 回答

## 1. useCallbackが「関数を返すuseMemo」であることの意味

**回答：**
UseCallbackっていうのは、useMemoの第一引数に関数を設定するためのショートハンドみたいなもので、結局、中でuseMemoを実行しています。キャッシュとして関数自体を保存しています。なので、useMemoとuseCallbackの本質的な違いはなく、キャッシュする値が関数なのか関数じゃないのかの違いだけです。

> **✅ 評価: 正しい** - useCallbackがuseMemoのショートハンドであること、内部的にuseMemoを実行していること、キャッシュ対象が「関数そのもの」であるという違いだけであること、いずれも正確です。


---

## 2. React.memoをつけているのにChildが再レンダーされる理由

**回答：**
React.memoをつけたとしても、React.memoで判断できるのは浅い比較までなので、実際にその内容を見て同一のものかどうかという判断はしていません。その前提でいうと、Parentコンポーネントでレンダリング中に毎回handleClickという関数が再生成されています。内容はコンソールログに出力するだけなんですけど、毎回再生成されているので参照は常に変わっています。この参照が変わるということは、React.memoにおいて全く違うpropsが渡ってきたというふうに判断されるので、React.memoを使ったとしても、Childコンポーネントは再度レンダリングされます。

> **✅ 評価: 正しい** - React.memoの浅い比較（shallow comparison）の説明、レンダーのたびにhandleClickが新しい関数として再生成されること、そのため参照が毎回異なりReact.memoが「propsが変わった」と判断すること、すべて正確です。「参照」というキーワードを使って的確に説明できています。

---

## 3. useCallbackを使うこと自体のコスト

**回答：**
UseCallbackを呼び出すときに、必ず依存配列で指定している情報の差分チェックが入ります。この差分チェック自体に大きな計算コストが発生してしまうと、そもそもトータルで見たときにパフォーマンスが逆に下がってしまうという事態が発生するケースがあるので、依存配列に指定するもののデータのサイズが大きいと、それなりにuseCallbackを実行するときのコストはかかります。

> **✅ 評価: 概ね正しい** - 依存配列の差分チェックにコストがかかるという指摘は正しいです。補足すると、依存配列の比較コストに加えて、もう少し広い視点でのコストもあります。useCallbackを使うこと自体が、hooks配列へのエントリ追加・前回の依存配列の保持・関数オブジェクトのメモリ保持を意味するので、**そもそもReact.memoされた子コンポーネントに渡していない関数をuseCallbackでラップしても、メモリとHook処理のオーバーヘッドだけが増えて何のメリットもない**、という点が実務的には最も重要なコストです。
