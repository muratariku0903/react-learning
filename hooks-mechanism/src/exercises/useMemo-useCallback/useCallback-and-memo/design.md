## なぜ親のstate変更で子が再レンダーされるのか
コンポーネントがメモ化されていないため、親コンポーネントが再度レンダリングされたら、それに連れて子コンポーネントもレンダリングされます。

## どのHook/APIを使ってどう修正するか
コンポーネントをReact.memoでラップしてメモ化します。こうすることでプロップスの値に変更が入らない場合、同じ値だった場合はキャッシュされたコンポーネントを使い回すようにします。またプロップスとしてコールバック関数を受け取っていますが、コールバック関数は適切にメモ化をして参照がレンダリングごとに変わらないようにします。そのためにコールバック関数にはuseCallbackを適用します。

---

> **✅ 実装演習 評価: 完了** - 設計方針と実装が正確に一致しています。
>
> - **設計との整合性**: 「React.memoでラップ」→ `memo(function TodoItem...)` で実装済み。「コールバック関数にuseCallbackを適用」→ `useCallback((index: number) => {...}, [])` で実装済み。設計通りです。
> - **state配置**: 適切です。
> - **再レンダリング**: 元の実装では `() => handleDelete(i)` とインラインアロー関数をpropsに渡していたため、レンダーのたびに新しい関数が生成されていました。修正後は `handleDelete` をuseCallbackでメモ化し、`index` をpropsとして渡すことで子コンポーネント内で `onDelete(index)` を呼ぶ形にしています。これにより関数の参照が安定し、React.memoが正しく機能します。良い修正です。
