# 言語化演習 回答

## 1. パターンAとパターンBの比較

**回答：**
パターンAでは、expensiveResultはheavyCalc関数が再実行され、その結果が格納されます。パターンBの場合は、useMemoで結果がメモ化されているため、countの値が変更されてもheavyCalc関数は再度実行されません。元の値が使い回されます。

> **✅ 評価: 正しい** - パターンAではcountの変更によるレンダーでもheavyCalcが再実行される点、パターンBではuseMemoの依存配列に`text`のみを指定しているためcountの変更では再計算されない点、いずれも正確です。

---

## 2. useMemoとuseEffectの決定的な違い

**回答：**
いつ実行されるかという観点から説明すると、useMemoはレンダリング中に実行されます。一方、useEffectはレンダリングフェーズが終了し、DOMに反映された直後に実行されます。何を返すのかという観点から言うと、useMemoはキャッシュされた値を返します。依存配列に指定された値が異なっている場合は、それを元にメモ化された値を再度計算して返します。useEffectの場合は、何を返すかというよりも、裏でReactが依存を解除するためのクリーンアップ関数を返します。そのため、useEffectが返却した値を使ってJSXで何か値を表示するという用途ではないです。

> **✅ 評価: 概ね正しい** - 実行タイミングの違い（useMemo=レンダリング中、useEffect=DOM反映後）と、返すものの違い（useMemo=計算済みの値、useEffect=クリーンアップ関数）の両方を正確に捉えています。特に「useEffectの戻り値はJSXで使う用途ではない」という指摘は、両者の根本的な役割の違いをよく理解しています。

---

## 3. userInfoをuseMemoでラップする意味

**回答：**
結論、意味ないと思っています。まず一つ目の理由として、メモ化するほどのものでもないのかなというふうに思っています。ネームとメールの項目を持ったオブジェクトを生成するだけなので、それをするためだけにuseMemoを使うのは、かえって過読性を下げることになるだけです。また、useMemoの依存配列としてuserが指定されています。このuserがいつ変更されるのかというと、useEffectの中のfetchUserでuserを取り出してそれを設定することによってですが、userはオブジェクトなので、たとえuserの中身の項目が全て同じだったとしても、全く違うデータとして処理されます。なので、実際useEffectの処理が実行されると、必ずこのuseMemoでラップしている処理は再度計算されることになるので、メモ化の意味を成していません。

> **🔍 評価: 漏れあり** - 「計算コストが低いのでメモ化の意義が薄い」という指摘は良い視点です。ただし、「userが変わるたびに再計算されるのでメモ化の意味がない」という結論には再考が必要です。
>
> 質問：このProfileコンポーネントが再レンダーされるのは、`user`がsetUserで更新されたときだけでしょうか？他にどんなケースが考えられますか？その場合、useMemoがあることで`userInfo`の参照はどうなりますか？そして、`UserCard`がもし`React.memo`でラップされていたとしたら、それはどう関係してきますか？

### このProfileコンポーネントが再レンダーされるのは、`user`がsetUserで更新されたときだけでしょうか？他にどんなケースが考えられますか？その場合、useMemoがあることで`userInfo`の参照はどうなりますか？そして、`UserCard`がもし`React.memo`でラップされていたとしたら、それはどう関係してきますか？
見落としていました。Profileコンポーネントが再度レンダリングされるのは、ユーザーを設定したときだけでなく、例えば親コンポーネント、読み出し元である親コンポーネントで何かしらのレンダリングを発したとき、Profileコンポーネントも子コンポーネントなので再度実行されます。このようなときにuserInfoがメモ化してあると、内部で返しているUserCardコンポーネントのpropsとしては変更が入らないことになりますので、そういった意味ではUsercCardが再度レンダリングされないという意味で最適化されているかなと思います。ただし、そこまで最初に言った通り、重い処理ではないので、メモ化するほどではないかなと思っています。

> **✅ 評価: 概ね正しい** - 親コンポーネントの再レンダーによってProfileが再実行されるケースを正しく捉え、その際にuseMemoがあればuserInfoの参照が維持され、React.memoされたUserCardの不要な再レンダーを防げるという点も正確です。「重い処理ではないのでメモ化の必要性は低い」という判断も実務的に妥当です。補足として整理すると、このuseMemoの意味は「計算コストの節約」ではなく「参照の安定化」にあります。UserCardがReact.memoされている場合には効果がありますが、されていない場合は効果がないため、**useMemoが意味を持つかどうかはUserCardの実装次第**ということになります。
