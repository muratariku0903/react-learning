# 言語化演習 回答

## 1. use(promise)の動作とSuspenseとの連携プロセス

**回答：**
初回レンダーの際に use で受け取ったプロミスの状態を確認し、そのプロミスが未解決の場合はプロミスをスローします。そのスローされたプロミスをサスペンスがキャッチして、フォールバックで指定されているコンポーネントを表示します。スローされたプロミスが解決されるまで、fallback で指定したコンポーネントを保持し続けます。プロミスが完了すると、Suspenseがそれを検知して、それをトリガーとしてコンポーネントを再レンダリングします。use で渡っているプロミスが解決されているので、use はプロミスをスローするのではなく、その中で解決した値を返します。最終的にコンテンツが表示されるという流れです。

> **✅ 評価: 正しい** - Promiseのスロー → Suspenseキャッチ → fallback表示 → 解決検知 → 再レンダー → 値返却、という一連のプロセスを正確に説明できています。


---

## 2. コードのパフォーマンス問題

**回答：**
こちらのコードでは、サスペンスでラップしているユーザープロファイルの中でプロミスを生成しています。この状態だと、ユーザープロファイルでスローされたプロミスをサスペンスが監視して、そのプロミスが解決されたら再度ユーザープロファイルをレンダリングするという流れになるんですけど、そうするとまたユーザープロファイルの中でプロミスが生成されて、またそれをスローしてという、無限にサスペンスに対してプロミスをスローすることになるので、無限ループになります。
そのため、SuspenseでラップしているコンポーネントでPromiseを生成するのではなく、外部からパラメータとしてPromiseを受け取るようにすればいいかなと思います。

> **✅ 評価: 正しい** - レンダーのたびにfetch()が新しいPromiseを生成し、無限ループに陥る問題の本質を正確に捉えています。修正方針も妥当です。


---

## 3. レンダーのたびに新しいPromiseを作ってはいけない理由

**回答：**
Useでは受け取ったプロミスが異なるものであるか、あるいは同一のものであるかというのは参照が同じかどうかで判断しています。レンダーのために新しいプロミスを作ってしまうと、そのプロミスを受け取ったuseは全く異なるプロミスであるというふうに解釈します。その結果、新たにプロミスの状態を確認して、サスペンスにプロミスをスローすることになってしまいます。そうなると、サスペンスの制御によって、再レンダリングが実行されると、それによってまた新しいプロミスがuseに渡されるので、またuseからサスペンスにプロミスをスローするという無限ループが発生してしまうという問題があります。

> **✅ 評価: 正しい** - Promiseの参照同一性による判定メカニズムと、それが崩れた場合の無限ループの発生過程を正確に説明できています。

