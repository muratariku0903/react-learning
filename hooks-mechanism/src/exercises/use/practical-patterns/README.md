# use フック - 実践パターンと注意点

## 目的

この演習では、以下を理解することを目指します：

- `use`フックの適切な使いどころとアンチパターン
- サーバーコンポーネントの`await`とクライアントコンポーネントの`use`の使い分け
- Promiseのキャッシュ戦略の重要性

## 要件

### 言語化演習（answer.mdに回答）

以下の質問に回答してください：

1. **サーバーコンポーネントで非同期データを取得する場合は`await`、クライアントコンポーネントでは`use`が推奨されています。ロードマップの注意点に「`await`はレンダリングを中断した場所から再開するが、`use`はコンポーネント全体を再レンダリングする可能性がある」と書かれていますが、この違いはなぜ生じるのですか？自分の理解で説明してください。**

2. **以下の2つのパターンを比較してください。パターンAには問題がありますが、パターンBは正しい実装です。なぜパターンBが正しいのか、Reactのレンダリングサイクルの観点から説明してください。**

   ```jsx
   // パターンA（問題あり）
   function DataView() {
     const data = use(fetchData()); // レンダーのたびに新しいPromise
     return <div>{data}</div>;
   }

   // パターンB（正しい）
   const dataPromise = fetchData();
   function DataView() {
     const data = use(dataPromise); // 同じPromiseを再利用
     return <div>{data}</div>;
   }
   ```

3. **`use`はReact 19で導入された新しいAPIですが、それ以前は`use`なしでどのようにクライアントコンポーネントで非同期データを扱っていましたか？従来のパターンと`use`パターンをコード例なしで比較し、`use`が解決した課題を説明してください。**

### 実装演習（design.mdに設計を記載後、実装）

`App.tsx`にはアンチパターンで実装されたデータ取得コンポーネントがあります。以下の問題を修正してください。

1. まず現状のコードを実行し、コンソールを確認して何が起きているか把握してください
2. `design.md` に以下を記載してください：
   - 現状のコードの問題点（具体的に何が起きているか）
   - 修正方針
3. アンチパターンを修正し、正しい`use`パターンに書き換えてください

## 制約条件

- `useEffect` + `useState` パターンに書き換えるのではなく、`use`を使った正しいパターンに修正すること
- Suspenseの配置も必要に応じて見直すこと
- ダミーデータや遅延時間は変更しないこと

## ヒント

- コンソールログに注目すると、fetchが何回呼ばれているか分かります
- Promiseの「同一性」がポイントです。JavaScriptでは `fetchData() === fetchData()` は `false` です
- Promiseをキャッシュする方法はいくつかあります（モジュールスコープ変数、親コンポーネントからのprop渡しなど）
