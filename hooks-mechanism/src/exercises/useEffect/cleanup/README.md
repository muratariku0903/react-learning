# useEffect クリーンアップ - リソースの解放と同期

## 目的

この演習では、以下を理解することを目指します：

- クリーンアップ関数がなぜ必要なのか
- クリーンアップ関数がいつ実行されるのか
- useEffectを「ライフサイクル」ではなく「同期」として捉える視点

## 要件

### 言語化演習（answer.mdに回答）

以下の質問に回答してください：

1. **クリーンアップ関数は「いつ」実行されますか？2つのタイミングを説明してください。**

2. **以下のコードでクリーンアップ関数がないとどんな問題が起こりますか？**
   ```jsx
   function ChatRoom({ roomId }) {
     useEffect(() => {
       const connection = createConnection(roomId)
       connection.connect()
       // クリーンアップ関数がない！
     }, [roomId])

     return <div>チャットルーム: {roomId}</div>
   }
   ```

3. **「useEffectはcomponentDidMount/componentWillUnmountの代替」という理解は、なぜ不正確なのでしょうか？「同期」という観点から説明してください。**

### 実装演習（design.mdに設計を記載後、実装）

`App.tsx` には、マウスの位置を追跡するコンポーネントがあります。現在、以下の問題があります：

- 「追跡ON/OFF」を切り替えるたびにイベントリスナーが追加され続けている
- コンポーネントがアンマウントされてもリスナーが残っている
- コンソールに警告やエラーが出る可能性がある

**タスク：**
1. 現状のコードを実行し、問題を確認してください
2. `design.md` に以下を記載してください：
   - 現在のコードの問題点
   - なぜリスナーが蓄積するのか
   - 修正方針
3. クリーンアップ関数を追加して適切に修正してください

## 制約条件

- `addEventListener` / `removeEventListener` を使うこと
- 追跡OFFの時はイベントリスナーが登録されていない状態にすること
- 「表示/非表示」ボタンでコンポーネントを切り替えた時も、リスナーが適切に解除されること

## ヒント

- ブラウザの開発者ツールで、イベントリスナーが何個登録されているか確認できます
  - Elements タブ → Event Listeners
- console.log でリスナーの追加/削除を可視化すると問題が見つけやすくなります
