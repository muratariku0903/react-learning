# 実装演習 設計メモ

## 現在のコードの問題点
UseEffectのクリーンアップ関数がリターンされていません。これによって追跡をオフにしたにもかかわらず、クリーンアップ関数が実行されないことによってイベントがリセットされないので、ONにしたときと同じようにトラッカーの追跡が維持され続けてしまいます。


## なぜリスナーが蓄積するのか
こちらも現在のコードの問題点と同じで、cleanup関数がリターンされていないことで、毎回useEffectの処理が実行されるたびにイベントリスナーが登録されてしまいます。



## 修正方針
イベントリスナーを登録した処理の後にクリーンアップ関数を返します。クリーンアップ関数ではイベントのリセットを実施します。こうすることによって、依存配列の状態が変化した後にそのクリーンアップ関数が次の副作用の実行の直前に呼ばれるので、常に一つだけのイベントが登録されることになります。

> **✅ 評価: 良好** - 問題分析と修正方針が的確で、実装も設計通りに行われています。制約条件もすべて満たしています。
>
> **🤔 追加質問:** 現在の実装では、`isTracking`がfalseのときはif文の中に入らないため、クリーンアップ関数がreturnされません（undefinedが返る）。この場合でも正しく動作する理由を考えてみてください。つまり、isTrackingがtrue→falseに変わったとき、前回のeffectで返されたクリーンアップ関数はどうなりますか？
IsTrackingがfalseのときは、そもそもイベントを登録しないので、クリーンアップ関数をリターンする必要はありません。isTrackingがtrueになったときに、ブラウザにイベントが登録されます。その場合は、次回以降の副作用を実行する直前に登録されたイベントを解除する必要があるので、isTrackingがtrueのときはクリーンアップ関数を返します。ただし、イベントを登録していないのであれば、クリーンアップ関数を返していません。

> **✅ 評価: 概ね正しい（完了）** - 「falseのときはイベントを登録しないのでクリーンアップ不要」「trueのときだけクリーンアップを返す」という理解は正しいです。補足として、ここで押さえておきたいポイントは、**Reactは前回のeffectが返したクリーンアップ関数を保持している**という点です。isTrackingがtrue→falseに変わると、Reactはまず**前回（trueの時）のeffectが返したクリーンアップ関数**を実行し（→removeEventListener）、その後で今回（falseの時）のeffectを実行します（→if文に入らず何もしない）。つまり、今回のeffectがクリーンアップを返さなくても、**前回のクリーンアップが正しく実行される**ので問題ないということです。
