# 言語化演習 回答

## 1. クリーンアップ関数の実行タイミング

**回答：**
クリーンアップ処理はコンポーネントがアンマウントされたときに実行されます。
また、依存配列の状態が変更を受け、副作用が実行される直前にも実行されます。

> **✅ 評価: 正しい** - 2つのタイミング（アンマウント時・依存変更による再実行直前）を正確に説明できています。


---

## 2. クリーンアップ関数がない場合の問題

**回答：**
クリーンアップ処理がないと、チャットルームというコンポーネントがアンマウントされたとき、つまり非表示になったときにもかかわらず、コネクションがずっとつながったままになってしまいます。なので、永遠にネットワークリソースを消費し続けるという問題が発生します。

> **⚠️ 評価: 漏れあり** - アンマウント時の問題は正しいです。ただし、もう1つ重要なケースが触れられていません。Q1で回答した「2つのタイミング」を思い出してください。このコードでは依存配列に`[roomId]`が指定されています。**roomIdが変わったとき（例: ユーザーが別のチャットルームに切り替えたとき）**、クリーンアップがないとどうなりますか？前のルームのコネクションはどうなりますか？この観点を追記してください。
アンマウント時に加えて、roomIdが変わったときのクリーンアップ処理がなされません。つまり、roomIdが変わったにもかかわらず、前のコネクションがずっと維持され続けることになります。createConnectionで新しいコネクションを貼り直すんですが、クライアント側では前のコネクション接続のソケットがずっと維持され続けますし、サーバー側でも前の接続がずっとつないだままになってしまうので、例えば新しいChatRoomで前のチャットが二重で表示されるみたいな予期せぬバグにつながってしまいます。

> **✅ 評価: 正しい（完了）** - roomIdの切り替え時に前のコネクションが残り続けて蓄積する問題を的確に説明できています。クライアント側・サーバー側双方のリソース問題と、二重表示という具体的なバグまで言及している点が良いです。


---

## 3. 「ライフサイクルの代替」ではなく「同期」である理由

**回答：**
UseEffectは、componentDidMount、componentWillUnmountと違って、単にマウントしたりアンマウントしたときのみに実行されるのではなく、依存配列に変更があったときにも実行されます。依存配列に変更があった際は、クリーンアップ処理をし、前回の依存を解除して新しい依存を設定する。そうした一連の流れが同期という設計思想となっています。

> **✅ 評価: 概ね正しい** - 依存配列変更時のクリーンアップ→再セットアップの流れを「同期」として捉えられています。補足として、「同期」の核心をもう少し掘り下げると、useEffectは**外部システム（DOM、ネットワーク、タイマーなど）をReactのstateと同期させる仕組み**です。「マウント時に接続する」「アンマウント時に切断する」というイベント思考ではなく、「roomIdが変わったら、そのroomIdに接続している状態を常に保つ」という**現在のstateに一致した外部状態を維持する**ことが目的です。
