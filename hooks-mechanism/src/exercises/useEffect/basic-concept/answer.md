# 言語化演習 回答

## 1. レンダー中の副作用の問題点

**回答：**
Reactにおいて、コンポーネントにおけるレンダリングは常にピュアでなければならないという思想があります。つまりレンダリングの結果がステートとプロップス、この2つによって必ず一定に定まるということです。この思想のもと、そのレンダリングの最中に他の例えばAPI呼び出し、DBを更新したり、ローカルストレージの値を更新したり、あるいはまた参照したりといった外部に影響を与えるような処理、つまり副作用を実行してしまうと、レンダリングの結果が同じStateとPropsにもかかわらず、1回目と2回目で結果が違うみたいな形で、回数によって結果が異なってしまうと。そういった中で、Reactは裏でレンダリングプロセスというものを最適化していて、レンダリングを並列でやったり、レンダリングを途中で止めてあるいは再開したりという、吉なに最適化しているので、そういった最適化の中で外部に影響を与えてしまうと、レンダリング結果が一定に定まらない。 そうなってくると予期せぬ不具合が発生します。Strict Modeというのは、こうしたピュアじゃない外部に影響を与えているレンダリングについて、早期的に検知できるような仕組みです。例えばあえてレンダリングを2回実行するというプロセスをストリクトモードで設けているので例えばAPIをレンダリング中に呼び出すみたいなことをすると不具合に早く気づける工夫がされています

> **✅ 評価: 概ね正しい** - レンダーの純粋性、副作用による問題、Reactの内部最適化（並列実行・中断・再開）、StrictModeの役割について正しく理解されています。十分な回答です。


---

## 2. コードの問題点と修正方法

**回答：**
こちらについては、1と内容が重複するんですけど、まずレンダリングの処理の中で非同期処理、APIを呼び出しています。これはレンダープロセスが純粋なものではないので、例えばレンダリングが裏で2回実行された場合に、ユーザー情報の取得も2回実行される。本来であればユーザ情報の取得は1回でいいはずなので、複数回実行されるという面で、パフォーマンスにおいて不利な状況と言えるでしょう。修正するべき点としては、useEffectを使ってレンダーが終わって、内容がコミットされた後にAPIを呼び出すという実装に修正する必要があります。

> **✅ 評価: 概ね正しい** - レンダー中のfetch実行の問題と、useEffectへの移行という修正方針は正しいです。補足として、このコードにはもう一つ重大な問題があります。レンダーのたびにfetchが実行され、`setUser(data)` がstateを更新し、それがまた再レンダーを引き起こし、再びfetchが発火する…という**無限ループ**に陥るリスクがあります。useEffectに移し、`[userId]` を依存配列に指定することで、userIdが変わったときだけ実行されるようにする必要があります。


---

## 3. renderフェーズとcommitフェーズの違い

**回答：**
レンダーフェーズは差分を検証するフェーズです。コンポーネントの計算結果、つまりJSXを基に、前回の結果、それは多分内部でファイバーとして管理されているものだと思うんですけど、そこの結果と今回の計算結果を比べて差分があるかないかっていうのを判定するフェーズです。それがレンダーフェーズです。コミットフェーズは、前のレンダーフェーズの結果が出た差分ですね。差分をDOMに反映するフェーズのことです。useEffectが実行されるのは、このコミットフェーズが終わった後です。終わった直後、つまりDOMに反映された直後になります。

> **✅ 評価: 概ね正しい** - レンダーフェーズ＝差分計算、コミットフェーズ＝DOM反映、ファイバーへの言及、いずれも正しいです。補足として、useEffectの実行タイミングについてもう少し正確に言うと、コミット「直後」ではなく、**ブラウザがペイント（画面描画）した後に非同期で実行**されます。つまり、DOM反映 → ブラウザペイント → useEffect実行、という順序です。「コミット直後に同期的に実行」されるのは `useLayoutEffect` の方です。この違いは、画面のちらつき（フリッカー）を防ぎたい場面で重要になります。

