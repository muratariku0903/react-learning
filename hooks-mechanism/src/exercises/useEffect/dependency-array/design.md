# 実装演習 設計メモ

## 現在のコードが正しく動作しない理由
まず問題なのは、useEffectの依存配列にcountが指定されていないことです。isRunningだけ指定されていますが、それだけだとcountが変わったことによってuseEffectの処理を再実行されません。
また、useEffect内でカウントアップする処理で、ステートの値を直接参照しています。この状態だと、一番最初のステートをずっと使い回すことになるので、常に1で更新され続けることになります。



## 修正アプローチ
UseEffectの依存配列は変えません。代わりに、useEffectの中でカウントアップ処理をしているところで、直接ステートを参照しているところをコールバック関数を指定します。こうすることで、常に最新のステートを読み込んで、それを元にカウントを更新するコールバックが実行されることになります。よって、カウントは正しくカウントアップされます。また、依存配列にカウントを入れなかった理由としては、カウントアップされるたびに毎回useEffectの処理が実行されることになると思います。そうなると、毎回setIntervalが実行され、毎回インターバルが作成されることになるので、それは意味のないことなので、インターバルを1回だけ作成すればいいので、依存配列の変更はしませんでした。

> **✅ 評価: 良好** - 問題の分析と修正アプローチが的確です。特に「依存配列にcountを入れるとsetIntervalが毎回再作成される」というトレードオフを理解した上で、関数型アップデートを選択した判断が優れています。設計メモと実装の整合性も完全に取れており、制約条件（setInterval維持・停止可能・重複防止）もすべて満たされています。
