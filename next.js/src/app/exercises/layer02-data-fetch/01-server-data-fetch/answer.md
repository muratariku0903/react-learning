# 演習2-1: 言語化演習 回答

## Q1: fetch() のキャッシュオプション

| 設定 | いつデータを取得する？ | キャッシュはどうなる？ | 適切なユースケース |
|------|---------------------|---------------------|------------------|
| `cache: 'force-cache'` |初回だけデータを取得 |キャッシュが1回設定されたら、以降のデータ取得は基本的にキャッシュされた値を使い回します。 |あまりデータ更新が頻繁に発生しないコンテンツ、あるいは鮮度がそこまで重要ではないコンテンツの表示に使います。 |
| `cache: 'no-store'` |毎回オリジンにデータを取得しに行きます。 |キャッシュは基本利用しません。 |データ更新が頻繁に発生するコンテンツ、あるいはデータの鮮度が重要になるコンテンツ、常に最新のデータを表示したい画面などです。 |
| `next: { revalidate: N }` |初回時にデータを取得して、それ以降はキャッシュしたものを使います。ただ、revalidate の項目で指定した時間を経過したら、再度オリジンから取得しに行きます。 |指定した時間が経過したら、再度オリジンから取得してきた値でキャッシュを更新します。 |たまにページの鮮度を更新したいときなどのページ、例えばブログ記事などです。 |

**Next.js App Router における fetch() のデフォルトのキャッシュ挙動:**
デフォルトではキャッシュはせずに、毎度オリジンにデータを取得しに行きます。

> **📝 レビューコメント（Q1）:**
> 3つのキャッシュ設定の基本的な違いは正しく理解できています。デフォルト挙動の回答も正確です（Next.js 15 で `no-store` 相当に変更された）。
>
> 1つ追加で考えてほしいことがあります:
> `revalidate` について「指定した時間が経過したら、再度オリジンから取得してきた値でキャッシュを更新します」と書いていますが、**更新のタイミング**をもう少し正確に考えてみてください。
> - revalidate の時間が経過した直後の**最初のリクエスト**には、古いキャッシュと新しいデータのどちらが返されるでしょうか？
> - この挙動パターンには名前がついています。「stale-while-revalidate」というキーワードで調べてみてください。
Revalidateによって時間が経過した直後の最初のリクエストでは、まずキャッシュされたデータを返します。それを表示している間にバックグラウンドで最新のデータをオリジンから取ってきて、キャッシュを更新するという流れになります。

> **✅ レビュー完了（Q1）:** 正確です。stale-while-revalidate パターンを正しく理解しています。ユーザーに古いデータを即座に返しつつ、裏側で最新データを取得してキャッシュを更新する — この「ユーザーを待たせない」仕組みがポイントです。

---

## Q2: ISR と SSG の違い

**ビルド時に何が起きるか:**
ビルド時はどちらもHTMLを生成します。

**リクエスト時に何が起きるか:**
SSGはあらかじめ生成してあったHTMLを返却するだけです。ISRもあらかじめ生成してあったHTMLを返却しますが、一定時間経過後、バックグラウンドで新しいHTMLを生成します。

**データが古くなった場合にどうなるか:**
SSGはデータが古くなっても同じHTMLを返却しますが、ISRは時間が経過した後は新しく生成されたHTMLを返します。

**それぞれどのような場面で使うべきか:**
SSGは基本的にデータの内容、表示する内容が変わらないページ。ISRはそんなにコンテンツの内容の更新頻度は多くないけど、たまに更新されてほしいコンテンツ。
SSG: 会社概要ページ、利用規約、プライバシーポリシーなど
ISR: ブログ記事、商品カタログ、ニュース記事など

> **📝 レビューコメント（Q2）:**
> 基本的な違いは正しく説明できています。ユースケースの具体例も適切です。
>
> 1点だけ深掘りです:
> 「ISRは時間が経過した後は新しく生成されたHTMLを返します」とありますが、これはQ1で触れた「stale-while-revalidate」と同じ話です。時間が経過した直後のリクエストで、ユーザーには**古い**HTMLが返されるのか、**新しい**HTMLが返されるのか、考えてみてください。
> この点を正確に理解すると、Q1の revalidate の回答もより正確になります。
Q1と同じく、時間が経過した直後のリクエストでは、古いHTMLが返されます。で、バックグラウンドで新しいHTMLを生成してキャッシュに保存します。

> **✅ レビュー完了（Q2）:** 正確です。ISR の再生成が stale-while-revalidate と同じパターンであることを正しく結びつけられています。

---

## Q3: generateStaticParams の役割

**generateStaticParams は何のために使う関数か:**
動的ルートページをビルド時に事前生成するために、事前生成されるページ一覧を返す関数です。


**使う場合と使わない場合の挙動の違い:**
使う場合はページの初期アクセスにおいてあらかじめ生成されたHTMLを返すので、ページの表示速度は速いです。使わない場合はその時点でHTMLを生成することになるので、使う場合と比べて少しだけ表示速度は低下します。

> **📝 レビューコメント（Q3）:**
> 基本的な理解は正しいです。ビルド時の事前生成と表示速度の違いについて把握できています。
>
> もう少し踏み込んで考えてみてください:
> - `generateStaticParams` で指定した **以外** のIDにアクセスした場合、どうなるでしょうか？（例: ID=100 にアクセスした場合）
> - その挙動を制御するための設定（`dynamicParams`）があります。調べてみてください。
DynamicParams は 2 パターンあって、dynamicParams を true とした場合、generateStaticParams に含まれていないセグメントにアクセスした場合はその都度 HTML を生成してレスポンスし、その内容をキャッシュして、次回以降の同じリクエストに対してはキャッシュしたものを返すという挙動になります。dynamicParams を false とした場合は、404 にダイレクトするようになります。

> **✅ レビュー完了（Q3）:** 正確です。`dynamicParams: true`（デフォルト）ではオンデマンド生成+キャッシュ、`false` では 404 — この使い分けを理解できています。補足すると、`false` に設定するケースは「存在しないIDへのアクセスを明確に拒否したい場合」（例: ユーザーがURLを手打ちして不正なIDでアクセスする場合）などが挙げられます。
