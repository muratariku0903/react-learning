## 📝 実装レビュー

### 良い点
- 4つのページすべてが正しく Server Component（async 関数）として実装されている
- `cache: 'force-cache'`、`cache: 'no-store'`、`next: { revalidate: 10 }` の使い分けが適切
- `generateStaticParams` の実装が正確（APIから取得 → slice → id を string に変換）
- Next.js 15 の `params` が `Promise` である点に対応できている（`await params`）
- 各ページのUIに「SSR相当」「SSG相当」「ISR相当」と記載しており、対応関係を意識できている

### 考えてほしい点

**1. データ取得時刻の取得方法について**
現在、`e.headers.get("date")` でレスポンスヘッダーの日時を表示しています。これは動作しますが、README では `new Date().toLocaleTimeString('ja-JP')` を推奨していました。

- レスポンスヘッダーの `date` は**外部APIサーバーがレスポンスを返した日時**です
- `new Date()` は **Next.js サーバーが fetch を実行した時点の日時**です
- キャッシュの挙動を確認する目的では、どちらがより正確でしょうか？
  - ヒント: Next.js がキャッシュから返す場合、実際に外部APIへリクエストが飛ばないことがあります。その場合、レスポンスヘッダーの `date` はどうなるでしょうか？
- Cacheの挙動を確認する上では、外部APIサーバーがレスポンスを返した日時を利用するのが適切です。NewDateを使うと、サーバー内の処理時間になるので、応答ごとに結果が変わってくるのかなというふうに思ってます。というかFetchは毎回実行されるのでそういった意味ではNewDateは毎回更新されます。なのでキャッシュされているかどうかの確認には要することはできないかなと思います。DateっていうのはAPIサーバーがレスポンスを返した日時になるのでこちらの値は実際にオリジンに取得しに行ったときしか算出されない値になるので、キャッシュを返しているか返していないかの判別に利用することは適しているのかなと思います。

> **📝 レビューコメント:**
> `headers.get("date")` を使った判断自体は良いアプローチです。ただし1点補足:
> 「Fetchは毎回実行される」という認識は少し不正確です。`force-cache` の場合、Next.js はキャッシュにヒットすると**外部APIへのHTTPリクエスト自体を送信しません**。コード上 `fetch()` は呼ばれますが、Next.js のキャッシュレイヤーがリクエストをインターセプトし、保存済みのレスポンスを返します。
> さらに、**Full Route Cache** により、`force-cache` を使ったページは Server Component の実行自体がスキップされる場合もあります。つまり `new Date()` もページ内の `fetch()` も呼ばれず、ビルド時に生成されたHTMLがそのまま返されます。
> この点は今後 Layer 2 を進めていく中でより深く理解できるはずです。

**2. Post インターフェースの重複**
`Post` インターフェースが4つのファイルすべてに定義されています。現状の演習規模では問題ありませんが、実務では共通の型定義を一箇所にまとめることが多いです。どこに配置するのが適切か考えてみてください。
  
Type.tsっていう共通ファイルを作って、そこに定義して、それぞれの呼び出し元で参照するのがいいかなと思います。

**3. エラーハンドリング**
API呼び出しが失敗した場合の処理がありません。この演習ではオプションですが、次のことを考えてみてください:
- Server Component で fetch が失敗した場合、ユーザーには何が表示されるでしょうか？
- Layer 1 で学んだ `error.tsx` がここでどう活用できるか？


現状の実装だと、サーバー側のフェッチで失敗した場合、そのままエラーの内容やstack traceが画面上に表示されてしまうので、そうした場合を考慮してプロジェクト直下にerror.tsxを配置し、そちらの内容を表示するようにしました。

> **✅ 実装レビュー完了:**
> error.tsx の実装も確認しました。`"use client"` の指定、`error` / `reset` props の活用、再試行ボタンの配置 — Layer 1 で学んだ内容を正しく活用できています。演習ディレクトリ直下への配置も適切です。
