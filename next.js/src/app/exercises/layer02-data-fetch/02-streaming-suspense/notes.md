# 演習2-2: 実装レビュー

## 総評
3パターンすべて正しく実装されており、Streaming / Suspense の違いを体験できる構成になっています。

---

## no-streaming/page.tsx ✅
- 3つのfetchを直列に `await` しており、合計約6.5秒すべて完了するまで画面に何も表示されない
- 「Suspenseなしの従来パターン」として正しい実装

## with-loading/page.tsx + loading.tsx ✅
- loading.tsx が配置されており、ページ遷移時にローディング表示 → データ取得完了後に一括表示される
- no-streaming との違い（loading.tsxによる即時フィードバック）が体験できる構成

## with-suspense/page.tsx ✅ — 特に良い点あり
- 各データ取得を**個別の async コンポーネント**に切り出し、それぞれ `<Suspense>` で囲んでいる → 正しい
- **特筆すべき点**: 親コンポーネントで3つのfetchを `await` せずに先に呼び出し、Promise を子コンポーネントに渡している
  - これにより**3つのデータ取得が並列に開始**される
  - UserInfo: ~0.5秒、Posts: ~2秒、Comments: ~4秒でそれぞれ表示される
  - もし各子コンポーネント内で直接 `fetchXxx()` を呼んでいたら同じ結果になるが、親で開始することで「意図的に並列化している」ことが明確になっている
  - この「Promiseを先に開始して子に渡す」パターンは Next.js でも推奨されるアプローチ

---

## 逆質問（考えてみてください）
with-suspense の実装について、もしデータ取得を並列ではなく直列にしていたら（各子コンポーネント内で `fetchXxx()` を呼ぶ形にしていたら）、表示タイミングはどう変わっていたでしょうか？


直列だった場合は、多分その前のフェッチが終わるまで、次のフェッチが実行されないので、待ち時間は並列に比べて長くなるかなと思います。並列だった場合は同時に取得していくので、そのフェッチ単体の待ち時間になるんですけど、直列だと前のフェッチの待ち時間が加算されていくので累積の待ち時間になっちゃうので、一番最後のコンポーネントは多分その前のフェッチの待ち時間を全部待った時間プラスそのコンポーネントのフェッチ時間になってしまうかなと思います。

> **レビュー:** 「直列だと累積の待ち時間になる」という理解は一般論としては正しいです。ただ、この質問の文脈では少し補足が必要です。
>
> 今回の with-suspense では、各子コンポーネントが**それぞれ独立した Suspense 境界**に囲まれています。この場合、たとえ各子コンポーネント内で直接 `fetchXxx()` を呼んでも、React はサーバー側で各 Suspense 境界の中身を**並行してレンダリング**できるため、実際には3つのフェッチがほぼ同時に開始されます。つまり表示タイミングは今の実装とほぼ同じになります。
>
> 親で Promise を先に開始して渡すパターンの価値は、「並列化の意図をコード上で明示できる」ことと、「Reactのランタイム実装に依存せず確実に並列化できる」ことにあります。
>
> 直列になるのは、Suspense を使わずに1つのコンポーネント内で `await` を連続する場合（no-streaming パターン）です。
