# 演習2-2: 言語化演習 回答

## Q1: Streaming と従来の SSR の違い

**HTMLの送信タイミングはどう変わるか:**
従来のSSRの場合は、サーバー側でHTMLが完全に完成するまでクライアントに送信することはないのですが、ストリーミングになってからストリーミングを使うと、部分的にクライアントにHTMLを送信するようになります。すぐに表示できる部分は先に送信してしまって、時間がかかるものに関しては後から送信するという風にすることができます。


**ユーザーが最初のコンテンツを見られるまでの時間への影響:**
従来のSSRは、レスポンスが完全体になるまでユーザーを待つしかなかったんですけど、ストリーミングの場合は、とりあえず一旦表示できる部分は表示できるようになるので、ユーザーがコンテンツを見られるまでの時間は短縮するかなと思います。TTFBの観点からすると、ストリーミングの方がSSRよりパフォーマンスは高いです。またFCPに関しても、ストリーミングの方がSSRよりパフォーマンスは高いです。


**サーバー側の処理フローの違い:**
従来のSSRはデータをすべて取得してHTMLを生成し、レスポンスを返していたんですが、ストリーミングではまずHTMLの外側をクライアントに返します。データ取得が完了したごとに部分的にレスポンスを送信するようになります。

> **レビュー（Q1）:** 3つの観点すべて正しく理解できています。
> 「HTMLの外側をまず返す」「完了したごとに部分的に送信」という表現は的確です。
>
> 1点だけ補足質問：ストリーミングでは「後から送信されたHTML」がブラウザ上でどのように既存の表示を置き換えるのか、その仕組みについて考えたことはありますか？（ヒント：サーバーから送信されるのはHTMLだけではありません）
具体的な仕組みを解説すると、ストリーミングでサーバーから部分的に送られてくるデータはHTMLだけではなく、スクリプト要素も送られてきています。スクリプト要素が送られてきた断面のHTMLの要素を取得したデータで反映するというDOM操作をします。これによってクライアント側だけでフォールバックの表示内容が切り替わるという制御をしています。

> **レビュー（Q1 完了）:** 正確です。サーバーから `<script>` タグとともに完成したHTMLが送られ、そのスクリプトがfallbackをDOMから取り除いて実コンテンツに差し替える、という仕組みをしっかり理解しています。Q1は完了とします。

---

## Q2: Suspense 境界の設計判断

**A（ページ全体を1つの Suspense）:**
ページ全体を1つの Suspense とする場合、一番取得に時間がかかるコメント一覧の取得が完了するまで、ページ全体がローディング状態になるので、ユーザーが4秒経つまで何も画面が見れない状態になるので、そこまで UX の体験は良くないかなと思います。


**B（3つのセクションそれぞれ個別に Suspense）:**
こちらはそれぞれ3つをSuspenseでラップするので、それぞれ取得が完了したごとに表示されることになるので、ユーザーの体験は比較的Aよりはマシなのかなというように思います。


**C（ユーザー情報は Suspense なし、投稿+コメントをまとめて1つ）:**
こちらは投稿とコメントが1つのサスペンスとしてまとまっているので、画面のちらつきはBよりはない。投稿とコメントが一緒に表示されるので。ただ、待ち時間という観点、あるいは退屈しないという観点でいうと、Bよりは劣るかなと思います。


**自分の選択とその理由:**
私はBを採用したいと考えています。理由としては、CかBで迷ったんですけど、さすがにコメント一覧の取得で4秒かかるのはさすがに待てないかなと思うので、だったら投稿一覧2秒かかるんですけど、その取得が完了したらまずそれを表示してあげるっていう風にしてあげた方がユーザーは退屈しないで済むのかなと思ったので、ユーザーの退屈しないっていう観点で言うとBが最適かなと思いました。

> **レビュー（Q2）:** Bの選択は妥当で、理由づけも的確です。
> 各パターンの比較も正しく理解されています。
>
> 1点だけ追加で考えてみてください：
> 選択肢Cでは「ユーザー情報は Suspense なし」となっていますが、これは具体的にどういう意味になりますか？ユーザー情報の取得（0.5秒）が完了するまで、ページの**他の部分**（投稿やコメントのローディング表示含む）はどうなるでしょうか？
この場合は0.5秒間ユーザーに何も表示されない状態になります。この0.5秒間完了するまで、投稿やコメントのローディング表示なども何もない状態になります。ただ0.5秒なので、そんなに体感時間はないので、そこまでUXを損なうものでもないかなと思います。

> **レビュー（Q2 完了）:** その通りです。Suspenseで囲まれていないawaitはページ全体のレンダリングをブロックするため、ユーザー情報取得の0.5秒間は他のSuspenseのfallback表示すら出ません。「0.5秒なのでそこまで問題ではない」という実務的な判断も妥当です。Q2は完了とします。

---

## Q3: loading.tsx と Suspense の使い分け

**loading.tsx を使うべき場面:**
画面全体をローディング状態にしたいときなどは、loading.tsxを使うべきだと思います。表示するコンテンツすべてがそれぞれ連動しており、どれかのセクションが欠けたら表示が成り立たないといった、かなり密接したセクションの画面の場合は、部分的に表示してしまうと表示が成り立たないというケースがあるため、全体ローディング中にした方が良いと思います。


**直接 Suspense を使うべき場面:**
表示するセクションがそれぞれ分割されていて、それぞれが独立した意味を持つ場合は、Suspense を使うべきかなと思います。それぞれが独立していれば、それ単体として表示して問題ないと思うので、表示できる準備が整ったものから表示してあげていった方が、ユーザーは退屈せずに済むので、UX を向上できるかなと考えます。

> **レビュー（Q3）:** 「コンテンツが密接に連携している場合はloading.tsx」「独立したセクションはSuspense」という使い分けの判断基準は良いです。
>
> もう一歩踏み込んで考えてみてください：loading.tsx の内部的な仕組みについてです。Next.js は loading.tsx をどのように機能させていると思いますか？（ヒント：loading.tsx と Suspense はまったく別の仕組みなのか、それとも関連があるのか？）
イメージでいうと、loading.tsx と Suspense は内部的に同じものを使っていて、loading.tsx はそのファイルが配置されたセグメント配下を全体を Suspense でラップしているイメージになりますね。なので、そのファイルが配置されたセグメント配下、page.tsx も含めて promise がスローされたら、fallback で指定したコンポーネントを表示するという動きになります。根本的な仕組みは同じかなと思います。

> **レビュー（Q3 完了）:** 正確です。Next.js は loading.tsx を検出すると、内部的に `<Suspense fallback={<Loading />}>` でそのセグメントの page.tsx をラップします。つまり loading.tsx は「Suspense のシンタックスシュガー」と言えます。今回の with-loading パターンでそれを実体験できたはずです。Q3は完了とします。
