Reactコンポーネントにおける **「純粋性（Purity）」** は、

**Reactが安全・高速・予測可能に動くための前提条件**。

これはコーディング規約ではなく、**Reactの設計思想そのもの**に近い概念。

---

## 純粋なコンポーネントとは何か

Reactにおける「純粋」とは、次の条件を満たすこと。

> 同じ props / state を与えれば、常に同じ JSX を返す
> 

つまり、

- レンダリング中に **副作用がない**
- 外部の状態を **勝手に変更しない**
- 描画は **計算として完結**している

```
(props, state) → JSX
```

この関数が **決定論的** であることが重要。

---

## 数学的な「純粋関数」との対応

Reactの考え方は、純粋関数とほぼ同じです。

```jsx
// 純粋
f(x) = x *2
```

```jsx
// 非純粋
f(x) {
console.log(x);
global++;
return x *global;
}
```

Reactは **後者のような関数を描画で使うことを強く嫌う。**

---

## なぜ React は純粋性を要求するのか

理由は主に3つ。

### ① 再レンダリングが「何度起きても安全」

Reactはレンダリングを **いつでも・何度でも・途中で破棄** します。

![image.png](attachment:f7698b49-048a-4757-bb6b-d33fb01cb112:image.png)

もしレンダリング中に副作用があると：

- 二重実行で二重登録
- 途中キャンセルで中途半端な状態
- 並列レンダリングで競合

が発生します。

---

### ② 並列レンダリング（Concurrent）への対応

Reactは将来的・内部的に、

- レンダリングを分割
- 優先度付きで中断・再開
- バックグラウンドで試し描画

を行う。

```
render (試し)
  ↓ 中断
render (再計算)
  ↓
commit
```

**render = 副作用なし**

**commit = 副作用OK**

という役割分担が成り立つのは、

レンダリングが純粋だから。

---

### ③ UIのデバッグが可能になる

純粋であれば、

- バグは state / props に原因がある
- ロジックと描画が分離される
- 再現性が高い

結果として、

> 「この state ならこの画面になる」
> 

が保証される。

---

## 純粋でないコンポーネントの典型例

### ❌ レンダリング中に副作用

```jsx
functionBad() {
document.title ="変更";// ❌
return<div>NG</div>;
}
```

### ❌ 外部変数の変更

```jsx
let count =0;

functionBad() {
  count++;// ❌
return<p>{count}</p>;
}
```

### ❌ 非決定的な処理

```jsx
functionBad() {
return<p>{Math.random()}</p>;// ❌
}
```

---

## 純粋なコンポーネントの例

```jsx
functionGood({ count }) {
return<p>{count}</p>;
}
```

- props のみを入力に
- JSX を返すだけ
- 外部に影響を与えない

---

## 「じゃあ副作用はどこでやるの？」

Reactは **場所を分けろ** と言っています。

| 場所 | 役割 |
| --- | --- |
| render | 純粋（JSX計算） |
| Effect | 副作用 |

```jsx
useEffect(() => {
document.title = count;
}, [count]);
```

---

## 純粋性と Strict Mode

開発環境では、Reactは **あえて2回レンダリングする**。

```
render
render（再実行）
commit
```

これは：

- 純粋でないコードを炙り出す
- 副作用の混入を検知する

ための **意図的な設計**。

---

## 純粋性を保つための設計ルール

### ✔ JSX 内では「計算のみ」

```jsx
const total = price * quantity;
```

### ✔ 副作用は Effect / Event Handler に閉じ込める

```jsx
onClick={() =>save()}
```

### ✔ 外部状態を書き換えない

- グローバル変数
- DOM
- storage
- time / random

---

## state との関係（重要）

**state 更新は副作用ではありません。**

```jsx
setCount(c => c +1);
```

理由：

- 更新要求を出すだけ
- 実際の変更は React が管理
- render中では実行されない

---

## まとめ（設計の核心）

- Reactコンポーネントは **描画専用の純粋関数**
- render中に副作用を起こしてはいけない
- 副作用は commit後にまとめて実行
- 純粋性があるから並列・中断・最適化が可能
