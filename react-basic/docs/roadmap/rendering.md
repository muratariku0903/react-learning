Reactの「レンダリング」は、一言でいうと **“状態（state/props）からUI（画面の見た目）を計算して、必要な差分だけを実DOMに反映する一連の流れ”** 。

ここでは「根本の仕組み」まで踏み込んで、Reactが内部で何をしているかを順番に説明。

---

## 1) まず「レンダリング」とは何か（Reactの定義）

![image.png](attachment:0d881041-680a-4104-8705-d8832bf8ac48:image.png)

Reactでレンダリングというと、だいたい次の2段階を指す。

1. **Render phase（計算フェーズ）**
    - `state` / `props` をもとに「次のUIはこうあるべき」を計算する
    - コンポーネント関数を呼び出して、**React要素（element）** のツリーを作る
    - ここではまだ実DOMは触らない（触らないことが重要）
2. **Commit phase（反映フェーズ）**
    - 計算結果をもとに、**実DOMを更新** する
    - `useLayoutEffect` / `useEffect` の実行など副作用もここに関係する

「再レンダリング」というと、多くの場合は **“コンポーネント関数が再実行されて、次のUIツリーが再計算される”** ことを意味する（必ずしもDOMが変わるとは限らない）。

---

## 2) Reactの根本思想：UI = f(state)

Reactは宣言的UIで、理想は↓。

- あなたは「今この状態ならUIはこう」と書く
- Reactは「前回と比べて変わったところだけ」反映する

つまり Reactは、毎回全部描き直してるように見せつつ、内部では **差分適用** をしている。

---

## 3) React要素（element）とコンポーネントの違い

レンダリングの理解で最重要なのがここ。

- **コンポーネント**：関数（またはクラス）。`props` を受け取って要素を返す。
- **React要素（element）**：`{ type, props, key, ... }` みたいな **「UIの設計図」**。軽いただのオブジェクト。

JSXは、最終的に「React要素」を作る糖衣構文。たとえば：

```jsx
<button className="a">OK</button>
```

は概念的には：

```jsx
React.createElement("button", {className:"a" },"OK")
```

のような「要素オブジェクト」を作っている。

Reactはまずこの要素ツリーを作り、それをもとに更新計画を立てる。

---

## 4) じゃあ差分ってどう取るの？（Reconciliation）

![image.png](attachment:a7876d58-40cb-49dc-9771-77c481863a49:image.png)

Reactが「前回のUI」と「今回のUI」を比べて更新点を見つける処理が **Reconciliation（調停/差分計算）** 。

ここでよく誤解されるのが「仮想DOM（Virtual DOM）」。

- 仮想DOMという言葉は「要素ツリー（＝JSオブジェクト）」を指す説明として使われがち
- 重要なのは **“仮想DOMが速い”** ではなく、**“Reactが差分計算して、必要な最小のDOM操作にする”** こと

### 差分計算のルール（超重要）

Reactは「完全な木の比較（全ノード同士の厳密比較）」はしません。

代わりに経験則のルールで高速化している。

1. **同じ階層で、要素の type が違えば、基本的にそのサブツリーは作り直す**
    - 例：`<div>` が `<span>` になったら、その下は基本全破棄→作り直し
2. **リストは key が一致するものを同一として扱う**
    - keyがない/不安定だと「別物」と見なされ、無駄な作り直しや状態のズレが起きる

この2つで、だいたいの挙動が理解できる。

---

## 5) さらに根本：Reactは「Fiber」というデータ構造で管理している

![image.png](attachment:129c3686-c14b-4f24-a29b-ed2ce6a18372:image.png)

React内部には **Fiber** という仕組みがある（React 16以降の中核）。

ざっくり言うと：

- React要素ツリー（あなたが書いた結果）を、そのまま処理しやすい形にした「内部ノード」が **Fiber**
- Fiberは「作業単位（unit of work）」として、**途中で処理を中断・再開できる** ように設計されている

### なぜ中断・再開が必要？

昔（React 15以前）は、レンダリング（差分計算）を一気にやっていました。

でもUIが重いと、メインスレッドを長時間ブロックして **スクロールがカクつく**。

Fiberにより、Reactはレンダリングを細切れにして、

- 重要な更新（入力追従など）は優先
- 重要度が低い更新（リストの再描画など）は後回し

みたいな **スケジューリング** ができるようになった。

---

## 6) レンダーの本当の流れ（更新が起きた瞬間から）

![image.png](attachment:cf7eb93e-4fd6-4e31-9de5-d31b1889d5fd:image.png)

例：ボタンで `setCount(count + 1)` を呼んだとする。

### (1) 更新がスケジュールされる

- `setState` / `setCount` は「更新を登録」する
- そのコンポーネント（正確にはFiber）に更新が紐づく

### (2) Render phase（差分計算）

- Reactが「次のUI」を計算するためにコンポーネント関数を呼び直す
- その結果できる「新しい要素ツリー」を使って、前回のFiberツリーと照合（reconcile）
- **“どのDOMをどう変えるか”** という作業計画（effect list的なもの）を作る

※ここでは **DOMは触らない**。だから中断・再開もできる。

### (3) Commit phase（DOM反映）

- 計画に沿ってDOMを更新（属性変更、テキスト変更、追加/削除など）
- refsの更新
- `useLayoutEffect` 実行（DOM反映直後・描画前に近いタイミング）
- ブラウザが描画
- `useEffect` 実行（描画後のタイミング）

---

## 7) 「再レンダリング = DOM更新」ではない

コンポーネントが再レンダリングされても…

- 差分計算の結果、DOMに反映すべき変更がなければ
- **CommitでDOM更新はほぼ起きない**

だから、Reactで「レンダーが走る」のは普通で、

本当にコストが高いのは「重い計算」や「大量のDOM変更」だったりする。

---

## 8) Reactが遅くなる典型ポイント（仕組みから見える）

仕組みが分かると、どこがボトルネックか見える。

- Render phase が重い
    - 再レンダリングで毎回重い計算をしている
    - 子が大量に再実行されている
- Commit phase が重い
    - DOM変更が大量（大きいリスト、複雑なレイアウト）
    - レイアウトスラッシング（`getBoundingClientRect` 連発など）に近いことをしている
- リストの key が不安定
    - 差分計算が崩れて無駄な作り直し + stateの紐づけミス

---

## 9) 最低限おさえるべき用語まとめ

- **Element**：UIの設計図（JSオブジェクト）
- **Reconciliation**：前回と今回のツリーを比べて差分を出す
- **Commit**：差分を実DOMに反映
- **Fiber**：内部のノード構造・作業単位。中断/優先度制御を可能にする
- **key**：リスト差分の「同一性」の鍵
