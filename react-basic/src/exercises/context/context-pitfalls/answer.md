# 回答

## 質問1: 頻繁に変わる値にContextが向いていない理由

頻繁に変更される値をContextで管理すると、購読してるコンポーネント全て再度レンダリングされるため、パフォーマンスの面で好ましくないから。

---

## 質問2: Contextに適しているもの/適していないもの

### 適しているもの

* ユーザー情報
  * ユーザー情報は頻繁に変わるものではないから
  * ユーザー情報はさまざまなコンポーネントから参照される可能性が高いから
* ダークモード/ライトモードの設定
  * ダークモード/ライトモードの設定は頻繁に変わるものではないから
  * アプリケーション全体に影響を与える情報だから
* アプリの言語設定
  * アプリの言語設定は頻繁に変わるものではないから
  * アプリケーション全体に影響を与える情報だから

### 適していないもの

* マウスの座標
  * 頻繁に変わる情報だから
  * その情報を利用するコンポーネントが限定的だから
* フォームの入力値（複数フィールド）
  * 頻繁に変わる情報だから
  * その情報を利用するコンポーネントが限定的だから
* リアルタイム更新されるチャットメッセージ一覧
  * 頻繁に変わる情報だから
  * その情報を利用するコンポーネントが限定的だから

---

## 質問3: 「Context = グローバルState管理」がアンチパターンになりやすい理由

### 理由1

全ての状態を1箇所のContextにまとめてしまうと、変更された状態に関連のないコンポーネントまで影響を受けてしまい、パフォーマンス低下につながるから。

### 理由2

コンポーネントがどんな状態を保持しているのか把握できなくなり、コンポーネント設計の可読性が低下する。それにより、Contextで管理してる状態をカスタムしたりメンテナンスしたりすることに対して影響範囲の特定に多くの時間を取られてしまう。

### 理由3

コンポーネントの状態を全てContextで管理すると、コンポーネントの独立性が下がってしまい、テストしづらくなってしまう（stateとpropsでJSXが確定するという純粋性を損なう）。また、コンポーネント単体で他の場所に使いまわしたいと言うときに、「Provider配下でないと使えない」と言う制約が生まれてしまい、再利用性が低下する。

---

## 評価コメント

3つの質問すべてに対して適切な理解が示されています。

- 質問1: Contextの再レンダリングの仕組みを正しく把握しています。
- 質問2: 「頻繁に変わるか」「利用範囲が広いか」という2つの観点で適切に判断できています。
- 質問3: パフォーマンス、保守性、テスタビリティ/再利用性という異なる視点から問題点を挙げており、深い理解が感じられます。

**完了**
