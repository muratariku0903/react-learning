# 言語化演習の回答

## 1. useEffect + fetch + useState で Suspense が反応しない理由

<!--
Suspenseが「待つ」ために必要な条件は何かを踏まえて説明してください。
-->
`useEffect` + `fetch` + `useState` のパターンでは、Promiseをスローしないため。Suspenseでは内部でラップしてるコンポーネントがPromiseをスローしないと機能しない。
useEffectを使うと、レンダリングのコミットフェーズが完了した後、つまり、コンポーネント描画後なので、Suspenseが待機状態を検知するためにレンダリング中にPromiseをスローする状況を作れない。

✅ 正しい理解です。「レンダリング中にPromiseをthrowする」というタイミングの重要性を正確に把握できています。useEffectは副作用であり、レンダリングが終わってDOMに反映された後に実行されるため、Suspenseの検知タイミングには間に合いません。


## 2. 「Suspense = fetchの代替」ではないの意味

<!--
Suspenseの本質的な役割は何かを説明してください。
-->
Suspenseの本質は「データを取りに行く（fetchする）」ことではなく、「コンポーネントが描画に必要なものをまだ用意できないときに、Promiseのthrowを合図にfallbackを表示して待つ」という描画側の制御にある。
そのため、fetchやキャッシュ、再取得、リトライ等の"取得戦略"はSuspenseの責務ではなく、別途（ライブラリやラッパー）が担う。

✅ 正しい理解です。Suspenseは「UI側の待機表示の宣言」であり、データ取得のロジックとは分離されているという点を正確に理解しています。責務の分離という観点も適切です。


## 3. Suspense対応ライブラリの工夫

<!--
TanStack Query等のライブラリがどのような工夫をしていると考えられるか、
wrapPromiseの実装を参考に推測してみてください。
-->
Promiseを受け取り、受け取ったPromiseの状態に合わせて、Promiseをスローするのか否かを制御する。Promiseが解決してない状態であれば、そのままPromiseを返し、解決したら、データを返却するといった処理が内部で実装されている。

✅ 正しい理解です。wrapPromiseの仕組みを理解した上で推測できています。実際のライブラリでは、これに加えてキャッシュ管理、エラー時のリトライ、リクエストの重複排除（deduplication）、stale-while-revalidateパターンなど、より高度な機能が実装されています。
