# Suspenseの基本的な使い方

## 目的

この演習では、Suspenseの最も基本的な使い方である「コンポーネントの遅延読み込み（lazy loading）」を理解します。
Suspenseがどのように「待つ」仕組みを実現しているのか、その基本的な考え方を身につけましょう。

## 背景

従来のReactでは、非同期処理のローディング状態を各コンポーネントで個別に管理していました。
これにより、ローディング制御が分散し、親子間でのローディングのズレやチラつきが発生しやすくなっていました。

Suspenseは「まだ準備ができていないコンポーネントがあれば、Reactに任せて待つ」という宣言的なアプローチを提供します。

---

## 要件

### 言語化演習

以下の質問に `answer.md` で回答してください。

1. 従来の `useState` + `useEffect` によるローディング管理と、Suspenseを使ったローディング管理では、**考え方**がどう異なりますか？「誰が」「何を」管理するのかという観点で説明してください。

2. `React.lazy()` を使うと何が起こりますか？また、なぜSuspenseと組み合わせる必要があるのですか？

3. Suspenseの内部的な動作として「Promiseをthrowする」という説明があります。これはどういう意味ですか？通常のtry-catchとの違いも踏まえて説明してください。

---

### 実装演習

現在の `App.tsx` には、`HeavyComponent` が直接importされています。
これを `React.lazy()` と `Suspense` を使って遅延読み込みに変更してください。

#### 現状のコード
```tsx
import HeavyComponent from "./components/HeavyComponent";
```

#### やること

1. `design.md` に設計メモを記載する
   - なぜ遅延読み込みが有効なのか
   - Suspenseの配置場所をどこにするか、その理由

2. 以下を実装する
   - `HeavyComponent` を `React.lazy()` で遅延読み込みに変更
   - `Suspense` で適切にラップし、ローディング中のUIを表示
   - ローディング中は「読み込み中...」と表示する

---

## 制約条件

- `useState` や `useEffect` でローディング状態を管理しないこと
- ローディングUI（fallback）は簡潔なテキストまたはシンプルなコンポーネントで構わない

---

## ヒント

- `React.lazy()` は動的インポート（`import()`）を返す関数を引数に取ります
- Suspenseの `fallback` プロパティには、ローディング中に表示するReact要素を渡します
- ブラウザのDevToolsでネットワークをスロットリングすると、ローディング状態を確認しやすくなります
