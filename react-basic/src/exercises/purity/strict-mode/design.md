* IdGenerator
  * 問題あり
  * グローバル変数をレンダリング中に更新してるので、idをステートで管理し、グローバル変数を更新しないようにする
* MessageRecorder
  * 問題あり
  * グローバル変数をレンダリング中に更新してるので、messageをステートで管理し、グローバル更新を参照しないようにする
* Counter
  * 正常

---

## 評価コメント

### 実装演習: 概ね完了 ✅

**良い点:**
- グローバル変数の使用をstateに置き換える方針は正しい
- StrictModeで二重レンダリングされても、stateなら値が一貫する理由を理解している

**確認ポイント（追加質問）:**

1. **IdGeneratorの初期値について**
   現在 `useState(1)` としていますが、元の要件は「訪問者番号」のようにインクリメントする機能でした。
   - 現在の実装では、常に `1` が表示されます
   - もし「コンポーネントがマウントされるたびにIDが増える」という要件なら、どう実装しますか？
   - これは純粋性の問題と関連しますが、「ID生成」という要件自体をどこで実現すべきか考えてみてください

2. **MessageRecorderについて**
   `useState([message])` としていますが、これは「初期値としてmessageを配列に入れる」という意味です。
   - 元の要件は「メッセージを記録し続ける」機能でした
   - 新しいメッセージを追加する機能が必要な場合、どう実装しますか？
   - 現在の実装で、propsの`message`が変わった場合、どうなりますか？

**回答:**

1. **IdGeneratorの初期値について**
   親コンポーネントでマウント回数を管理するステートを用意し、表示・非表示ボタンのイベントハンドラでステートを更新する。（表示の時のみカウントアップ）

2. **MessageRecorderについて**
   新しいメッセージを追加する機能が必要な場合、イベントハンドラ内でステートにメッセージを追加する処理を加える
   表示は変わらない、ステートで管理してる値を使用して表示してるので、ステートを更新しない限り、表示は変わらない（useStateの初期化処理は初回マウント時のみ実行されるので、props変動を追従しない）

---

## 最終評価コメント

### 追加質問への回答: 正しい ✅

**1. IdGeneratorについて**

回答は正しいです。「親コンポーネントでマウント回数を管理し、イベントハンドラで更新する」というアプローチは適切です。

ポイント:
- **状態の「リフトアップ」**: 子コンポーネントで純粋に保てない処理は、親に移動する
- **イベントハンドラでの更新**: レンダリング中ではなく、ユーザーアクションに応じて更新
- これにより、IdGenerator自体は純粋なコンポーネントのまま、機能要件を満たせる

**2. MessageRecorderについて**

回答は正しいです。

- `useState`の初期値は初回マウント時のみ評価される
- propsが変わっても、stateは自動的には追従しない
- propsの変更を追従したい場合は `useEffect` で同期するか、設計を見直す必要がある

**発展的な補足:**
propsの変更に追従したい場合の選択肢:
```jsx
// 方法1: useEffectで同期
useEffect(() => {
  setMessageLog(prev => [...prev, message]);
}, [message]);

// 方法2: keyを使ってコンポーネントをリセット
<MessageRecorder key={message} message={message} />
```

---

### 実装演習: 完了 ✅

純粋性の本質（「どこで」非純粋な処理を行うか）と、stateの初期化タイミングの理解が確認できました。
