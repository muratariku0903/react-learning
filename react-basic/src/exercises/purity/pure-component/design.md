* Greeting
  * 非純粋
  * JSXの計算結果がstate・propsのみ完結してないから
  * 内部で直接グローバル変数を使わず、propsとして受け取る
* CurrentTime
  * 非純粋
  * JSXの計算結果がstate・propsのみ完結してないから
  * 時刻を内部で生成せず、Greeting同様にpropsとして受け取り表示する
* PriceDisplay
  * 純粋
  * JSXの計算結果がstate・propsのみ完結してるから


### ここで質問があります。GreetingとCurrentTimeは純粋になりましたが、親コンポーネント（App）自体は純粋でしょうか？
- renderCountRef.current += 1 はレンダリングのたびに値を変更しています
- new Date() は呼び出すたびに異なる値を返します
- 純粋性の「問題を移動した」だけなのか、それとも「解決した」のか、考えてみてください。この設計で問題ないケースと、問題になるケースはどのような場合でしょうか？
### 回答
* 親コンポーネントは純粋ではないです。
* なので、純粋性の問題を移動したことになります。
* 問題になるケースは親コンポーネントである「App」が何度もレンダリングを実行されるケースです。親コンポーネントでステート管理をし、それを子コンポーネントないで更新したりすると問題です。なので、親コンポーネントはできるだけ再度レンダリングされないように実装を工夫する必要があります。

---

## 評価コメント

### 実装演習: 完了 ✅

**良い点:**
- 3つのコンポーネントの純粋性を正しく判定できている
- 非純粋なコンポーネントをpropsで受け取る形に修正し、子コンポーネントを純粋にできた
- 設計と実装が一致している

**追加質問への回答について:**

「問題を移動した」という認識は正しいです。補足すると：

1. **これは許容されるパターン**
   - Reactでは「純粋でない処理」を完全に排除することはできません（時刻取得やID生成など）
   - 重要なのは「**どこで**非純粋な処理を行うか」をコントロールすること
   - 今回の設計では、非純粋な処理をAppコンポーネント（ルート）に集約し、子コンポーネントは純粋に保っている

2. **この設計が問題ないケース**
   - Appがルートコンポーネントで、親から再レンダリングされることがない
   - 非純粋な処理の結果（時刻、カウント）が「表示用」であり、ロジックに影響しない

3. **問題になるケース**
   - StrictModeで二重レンダリングされると `renderCountRef.current` が2回インクリメントされる
   - この値をビジネスロジック（APIに送信するIDなど）に使うと不整合が発生する

**発展的な解決策:**
- 時刻表示：`useEffect` + `setInterval` で定期更新
- ID生成：サーバーサイドで発行、または `useId()` を使用


