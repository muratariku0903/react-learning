# 言語化演習 回答

## 1. 純粋関数の定義

### 純粋関数とは何か？

* 受け取ったパラメーターで処理結果が全て決まる関数のこと

### 純粋関数が満たすべき2つの条件

1. 受け取ったパラメーター以外を活用しない
2. 外部に影響を与えない

---

## 2. Reactにおける純粋性

### コンポーネントが「純粋である」とは？

同じ props / state を与えれば、常に同じ JSX を返す

### `(props, state) → JSX` の意味

同じ props / state を与えれば、常に同じ JSX を返す

---

## 3. 純粋性が必要な理由

### 理由1:

サイレンダリングが何度起きても安全。Reactは内部でレンダリングを何回も実行するので、そうした中で、副作用のある処理をしてると、最終的な計算結果が意図しないものとなってしまうケースがある。しかし、コンポーネントで純粋であれば、途中で止めても、計算結果は変わらないので、そうしたケースが起こりにくい。

### 理由2:

デバッグがしやすい。計算結果がstateとpropsによって必ず求まるので、バグやエラーが発生した際に、原因の特定がstateとpropsに限定することができるので修正が楽

### 理由3:

並列レンダリングに対応できる。Reactはレンダリングを細かく分割して並列で実行したりする。そうした際に、コンポーネントが純粋でないと、並列実行したそれぞれの処理が互いに影響を与えてしまって思わぬ不具合を引き起こすケースも考えられる

### 「再レンダリングが何度起きても安全」の具体例

ここでいう「レンダリング」とはJSXを計算するフェーズとする。
例えば、コンポーネント内部でAPIを呼び出すといった副作用があるコンポーネントではレンダリングが２回生じた場合二重登録といったバグが生じる。
```js
function Signup() {
  // ❌ render中に副作用（API）を起こしている
  fetch("/api/users", {
    method: "POST",
    body: JSON.stringify({ name: "muku" }),
  });

  return <div>登録中...</div>;
}
```
以下のように副作用を切り離し純粋なコンポーネントとすることで、何度レンダリングを使用と同じ結果となり上記のバグが発生しない。
```js
function Signup({ name }) {
  useEffect(() => {
    // ✅ commit後に実行される副作用
    const controller = new AbortController();

    fetch("/api/users", {
      method: "POST",
      body: JSON.stringify({ name }),
      signal: controller.signal,
    });

    return () => controller.abort();
  }, [name]);

  return <div>登録中...</div>;
}
```

---

## 評価コメント

### 言語化演習: 概ね正しい ✅

**良い点:**
- 純粋関数の2つの条件（入力のみに依存、外部への影響なし）を的確に捉えている
- Reactにおける純粋性の3つの理由（再レンダリング安全性、デバッグ容易性、並列レンダリング対応）を正しく理解している
- 具体例でAPIコールの問題とuseEffectでの解決策を示せている

**補足:**
- `(props, state) → JSX` の説明について、もう少し踏み込むと「**数学の関数のように、入力から出力が一意に決まる**」という決定論的な性質を強調できると良い
- 修正後のSignupコンポーネントの例で、クリーンアップ関数（`controller.abort()`）を入れているのは非常に良い観点。ただし、POST系のAPI呼び出しは通常useEffectではなくイベントハンドラで行う方が適切（ユーザーアクションに対する応答のため）
