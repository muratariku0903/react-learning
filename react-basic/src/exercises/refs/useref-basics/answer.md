# useRefの基本 - 回答

## 問1: useRefが返すオブジェクトの構造

`useRef(initialValue)` は `{ current: initialValue }` という形のオブジェクト（refオブジェクト）を返す。  
このオブジェクト自体はコンポーネントの同一インスタンス内で再レンダリングを跨いでも同じ参照が保たれ、`initialValue` は初回レンダリング時にのみ使われる。  
`current` はミュータブルで、`ref.current = ...` のように直接書き換えられる。一方で `current` を更新しても React はその変更を検知して再レンダリングしない（表示更新のトリガーにならない）。



---

## 問2: なぜDOM操作にuseRefを使うのか

ReactではDOMの更新において主導権はReactにあるので、Reactの監視下においてDOMを参照する必要がある。document.getElementByIdで直接DOMを参照してしまうと、ReactがまだDOMをコミットしてないタイミングで要素を探しにいってしまうが、useRefはDOMがコミットされてから実行されるので、ライフサイクル的に安全。  
また、getElementById はアプリ全体からDOMを探すためコンポーネントの境界を越えてしまう一方、ref は そのコンポーネントツリー内で明示的に紐付けた要素を参照するので、意図しないDOM参照が起きにくい。



---

## 問3: useRefの「再レンダリングされない」特性

### 画面に表示される数値の予想:

「０」と表示される

### その理由:

イベントハンドラでrefの値がインクリメントされているが、再レンダリングは発生しないので、表示は変わらない。

---

## 評価コメント（言語化演習完了）

### 問1 ✅
`{ current: initialValue }`という構造、参照の同一性（再レンダリングを跨いでも同じオブジェクト）、ミュータブル性、そして再レンダリングを引き起こさない点を正確に説明できています。

### 問2 ✅
以下の2つの重要な観点を的確に捉えています：
1. **ライフサイクル的な安全性** - ReactがDOMをコミットした後に参照されることが保証される
2. **スコープの明確さ** - コンポーネントツリー内で明示的に紐付けた要素のみを参照できる

補足として、ReactのStrictModeでは開発時にコンポーネントが2回マウントされることがありますが、refはその場合も正しく動作します。`getElementById`だとIDの重複などで予期しない動作が起こる可能性があります。

### 問3 ✅
refの更新は再レンダリングをトリガーしないため、画面表示は初期値「0」のまま変わらない点を正しく理解しています。コンソールには1, 2, 3...と内部値が出力されますが、それがUIに反映されないのがrefの特性です。
