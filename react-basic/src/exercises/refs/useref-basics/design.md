# ストップウォッチ - 設計メモ

## 実装前に考えること

<!--
以下の点について考えて記述してください：

1. どのような状態（state）が必要か？
2. useRefで何を保持するか？なぜstateではなくrefを使うのか？
3. タイマーの開始・停止・リセットの処理フロー
4. クリーンアップはどのタイミングで行うか？
-->

1. どのような状態（state）が必要か？
画面に表示する秒数をstateとして管理する


2. useRefで何を保持するか？なぜstateではなくrefを使うのか？
タイマーIDを管理する。タイマーIDはタイマーを停止する際に利用する。
こうした情報は画面に表示するものではなく、かつ、レンダリングの影響を受けない値にする必要があるためuseRefにて管理する


3. タイマーの開始・停止・リセットの処理フロー
スタートボタンを押下
↓
setInterval関数実行
  refとしてタイマーIDを保存
　stateを1秒おきにインクリメントさせる

ストップボタンを押下
↓
タイマーIDの存在チェックをし、タイマーを停止し、タイマーIDを初期化（null）

リセットボタン押下
↓
ストップボタンを押下時と同等の処理
stateを初期化（0）


4. クリーンアップはどのタイミングで行うか？
コンポーネントがアンマウントされた時。

---

## 評価コメント（実装演習完了）

### 設計との整合性 ✅
設計メモで記述した内容がすべて実装に正しく反映されています：
- state（seconds）とref（setIntervalId）の使い分け
- スタート/ストップ/リセットの処理フロー
- useEffectでのアンマウント時クリーンアップ

### state配置 ✅
- `seconds`（UI表示用）→ state
- `setIntervalId`（内部管理用）→ ref

「画面に表示するかどうか」という判断基準で適切に使い分けられています。

### 実装の良い点
1. **二重起動防止**: `handleStart`で`setIntervalId.current !== null`をチェックしている
2. **クロージャ対策**: `setSeconds((prev) => prev + 1)`の関数形式更新を使用し、コメントでその理由も記載している
3. **クリーンアップ**: useEffectでアンマウント時のタイマー停止を実装している

### 補足：タイマーIDをstateで持つとなぜ問題か？
設計メモの「レンダリングの影響を受けない値にする必要がある」という記述について補足すると、もしタイマーIDをstateで管理した場合：
- `setIntervalId(id)`でstate更新 → 再レンダリング発生
- 再レンダリング中に古いIDでclearIntervalしようとしてもバッチ処理でまだ更新されていない可能性
- さらに、タイマーIDの変更自体はUIに影響しないため、不要な再レンダリングになる

この点を理解した上でrefを選択できているのは正しい判断です。
