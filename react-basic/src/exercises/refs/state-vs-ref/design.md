# 前回の値を表示するコンポーネント - 設計メモ

## 問題の分析

<!--
現在の実装を動かして、以下の点を記述してください：

1. どのような問題が発生しているか？
2. なぜその問題が発生しているか？（根本原因）
3. 現在のコードでstateとrefの使い方は適切か？
-->

### 0. この演習課題に思うこと
まず、「現状の問題」に記載されている以下の事象は実際に動作確認をしたが、確認できなかった。
- 「+1」ボタンを押しても、「前回の値」が正しく表示されない
- コンソールを確認すると、不必要な再レンダリングが発生している  

なので、演習を少し修正して、再レンダリングが観察しやすいように状態更新を「setTimeout」でラップしています。（できるだけ最初からわかりやすい演習にしてほしい。。）

### 1. どのような問題が発生しているか？
不要なレンダリングが発生してる。  
現在の値をインクリメントすることで、再度レンダリングされるのが理想だが、同時に、前回の値も更新してしまっているので、２回のレンダリングが発生してしまう。

## 修正方針

<!--
以下の点について考えて記述してください：

1. 何をstateで管理し、何をrefで管理すべきか？
2. なぜその設計が適切なのか？
3. 修正後の処理フローはどうなるか？
-->
前回の値はrefで管理し、レンダリングのトリガーにならないようにする。
ボタンが押下されたらrefで管理した前回の値を更新する

---

## 評価コメント（実装演習完了）

### 演習設計へのフィードバック
ご指摘ありがとうございます。元の演習では、Reactのバッチ処理（React 18以降は自動バッチング）により、同一イベントハンドラ内の複数の`setState`が1回のレンダリングにまとめられます。そのため「2回のレンダリング」という問題が観察しにくい状況でした。演習設計として改善が必要な点として認識しました。

### 設計との整合性 ✅
「前回の値はrefで管理」という設計意図が実装に正しく反映されています。

### 実装の評価 ✅

```tsx
const handleIncrement = () => {
  setCount((current) => {
    prev.current = current; // 「更新前」を確実に保存
    return current + 1;
  });
};
```

この実装は工夫されています：
1. **関数形式更新を使用** - 最新の`current`値を確実に取得できる
2. **更新前の値を保存してから新しい値を返す** - タイミングが正確

### 「前回の値」をrefで管理することの妥当性

今回の実装では「前回の値」を画面に表示していますが、refで管理しても問題ありません。なぜなら：

- `count`がstateで管理されており、それが更新されると再レンダリングが発生する
- 再レンダリング時に`prev.current`の最新値が読み取られて表示される

つまり、**「前回の値」自体が再レンダリングのトリガーになる必要はなく、`count`の更新に「便乗」して表示が更新される**という設計です。これはstateとrefの使い分けとして適切な判断です。
